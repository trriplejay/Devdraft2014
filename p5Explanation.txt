Errors from the top down:
1. The storing of addressLine.  This didn't cause an error, but since nearly every method of class Address started off by doing a split, it may have been more efficient to perform the split a single time during the init method, and store that in self.addressLine instead.  self.addressLine was never really used again (except incorrectly in the getZipCode method.
2.  The getStreetAddress method is never used in this example, but even if it were, it does not take into account the possibility that a street address could have multiple lines.  It only looks at the second before the first comma, so the second address line would be ignored
3.  The getCityName method again assumes that there was only one street address line, so there could be a case where we think we're returning the city, but return the second street address line instead
4.  The getState method suffers from the same problem as getStreetAddress and getCityName.
5. The getZipCode method is weird in a couple ways.  Firstly, it doesn't allow for the possibility that a person's address has 5 or more digits in it.  In that particular case, getZipCode will return the first 5 digits of the person's street address and ignore the actual zip code.  This issue happens because the engineer assumed zip would be the only 5 digit number in the entire string, when he/she could have just as easily split the string and only examined the last member of the list.  Along those lines, given that the documentation states that the addresses have been reasonably normalized, I think it would be safe to find our zipcode the same way we find our state: by doing a split around a space(" ").  No need to loop and try to count all 5 digits if we know we're looking at the zip, and we know the info was normalized when it was originally entered into the system.
6. The calculateTax method needed a few changes. It seems to assume that the state will be in proper capitalized format ("Arizona" vs "arizona") but we can see from the sample input that this is not always the case.  a solution would be to normalize the input by using the "lower" string method.  The if/if/if logic could also be changed to if/elif logic in order to reduce a few unnecessary comparisons.  If we match one state, there is no need to check the others.  I think I would also suggest that assuming this code might one day expand to include values for all 50 states, you might be better off building a dictionary that will allow you to perform an O(1) lookup to see if a value exists for your particular state (and if not, have a default).  In this case, that is not necessary since an if/else block of 4 items is not a big deal.  Also, it's a good idea to verify that your input is within the bounds that you expect it to be.  orderAmount should be an int, and neither state or orderAmount should be None.
7. The calculateShipping method had some bad logic when compared to the documentation.  "zipCode >= 75000" was changed to "zipCode > 75000" to match the description.  We also should verify that it is an int, and that it is not None.  These edge cases may be unlikely, but it is important to test them in unit test to make sure they are covered.  With enough users, edge cases are sure to be hit!


Coding practices:
1.  I don't think TaxCalculator and ShippingCalculator needed to be classes.  They did not take advantage of any features that would make a class beneficial (attributes, inheritance), they simply performed some basic logic.  They would have served their purpose just as well (and less verbosely) if they had been plain old functions.

2. Sparse comments.  It doesn't hurt to be more descriptive in the comments, even as far as explaining why something was done the way it was done.  Also would help to have a class description at the top.

3. Unit test.  Ok, so in theory the engineer could have written tons of unit tests in another module, but I'm going to assume he/she didn't, since there were so many missed edge cases.  I used official python unittest functionality to make sure the changes I made not only worked in failing cases, but didn't cause previously working cases to fail.